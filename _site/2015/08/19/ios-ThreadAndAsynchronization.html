<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="baidu-site-verification" content="w9Akh6dPe4" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
<!--[if lte IE 8]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

<title>ios的线程和同步异步操作 | 曾绍明的博客</title>
<meta name="author" content="曾绍明">

  <meta name="keywords" content="IOS,异步，同步,线程">




<link rel="shortcut icon" href="" />

<link rel="stylesheet" type="text/css" href="/assets/css/style.css">

<link href="/pages/rss.xml" rel="alternate" title="曾绍明的博客" type="application/atom+xml">



  </head>
  <body>
        <aside id="sidebar">
  <nav id="tags">
    <a href="/index.html" id="avatar" style="background-image:url(https://avatars1.githubusercontent.com/u/15245912)"></a>

    <ul id="tags__ul">
      <li id="pl__all" class="tags__li tags-btn active">所有文章</li>
       
        <li id="技术" class="tags__li tags-btn">技术</li>
       
        <li id="web前端" class="tags__li tags-btn">web前端</li>
       
        <li id="专题" class="tags__li tags-btn">专题</li>
       
        <li id="iOS" class="tags__li tags-btn">iOS</li>
       
        <li id="生活" class="tags__li tags-btn">生活</li>
       
        <li id="react-native" class="tags__li tags-btn">react-native</li>
       
        <li id="其他" class="tags__li tags-btn">其他</li>
       
        <li id="IoT" class="tags__li tags-btn">IoT</li>
      
    </ul>

    <div id="tags__bottom">
      <a href="http://github.com/ZSMSimon" id="icon-github" class="tags-btn fontello" target="_blank"></a>
      <a href="/pages/rss.xml" id="icon-feed" class="tags-btn fontello" target="_blank"></a>
      <a href="mailto:ZSMSimon@163.com" id="icon-email" class="tags-btn fontello"></a>
    </div>
  </nav> <!-- end #tags -->

  <div id="posts-list">
    <form action="" id="search-form">
      <a href="/index.html" id="mobile-avatar" style="background-image:url(https://avatars1.githubusercontent.com/u/15245912)"></a>
      <!-- NOTE: input field is disabled by default -->
      <input id="search-input" type="text" placeholder="Search..." >
    </form>

    <nav id="pl__container">
    
      <a class="IoT pl__all" href="/2017/05/16/JavaScript-mqtt-temperaturedemo.html"><span class="pl__circle"></span><span class="pl__title">IoT技术选型及模型设计的思考</span><span class="pl__date">17/05/16</span></a>
    
      <a class="IoT pl__all" href="/2017/05/02/hello-nodemcu.html"><span class="pl__circle"></span><span class="pl__title">hello nodemcu</span><span class="pl__date">17/05/02</span></a>
    
      <a class="其他 pl__all" href="/2017/03/16/Recruitment.html"><span class="pl__circle"></span><span class="pl__title">阿里云iot事业部招聘信息</span><span class="pl__date">17/03/16</span></a>
    
      <a class="技术 pl__all" href="/2017/01/23/zhihu-live-a-hour-for-bluetooth-0.html"><span class="pl__circle"></span><span class="pl__title">知乎live：一小时蓝牙科普 文字整理版</span><span class="pl__date">17/01/23</span></a>
    
      <a class="web前端 pl__all" href="/2016/12/08/eslint-guide.html"><span class="pl__circle"></span><span class="pl__title">ESLint使用</span><span class="pl__date">16/12/08</span></a>
    
      <a class="其他 pl__all" href="/2016/12/06/how-to-fupan.html"><span class="pl__circle"></span><span class="pl__title">柳传志：我的复盘方法论</span><span class="pl__date">16/12/06</span></a>
    
      <a class="react-native pl__all" href="/2016/11/14/react-native-flux%E6%95%B0%E6%8D%AE%E6%B5%81.html"><span class="pl__circle"></span><span class="pl__title">flux数据流在rn中的使用</span><span class="pl__date">16/11/14</span></a>
    
      <a class="专题 pl__all" href="/2016/05/09/iOS-networking-0.html"><span class="pl__circle"></span><span class="pl__title">iOS 网络请求专题</span><span class="pl__date">16/05/09</span></a>
    
      <a class="iOS pl__all" href="/2016/04/03/iOS-JavaScriptCore.html"><span class="pl__circle"></span><span class="pl__title">iOS JavaScriptCore使用</span><span class="pl__date">16/04/03</span></a>
    
      <a class="iOS pl__all" href="/2016/04/02/iOS-3DTouch-3.html"><span class="pl__circle"></span><span class="pl__title">iOS 3D touch开发(三) Force Properties-按压力度</span><span class="pl__date">16/04/02</span></a>
    
      <a class="iOS pl__all" href="/2016/04/01/iOS-3DTouch-2.html"><span class="pl__circle"></span><span class="pl__title">iOS 3D touch开发(二) peek and pop - 预览和弹出</span><span class="pl__date">16/04/01</span></a>
    
      <a class="iOS pl__all" href="/2016/03/21/iOS-3DTouch-1.html"><span class="pl__circle"></span><span class="pl__title">iOS 3D touch开发(一) Home Screen Quick Actions</span><span class="pl__date">16/03/21</span></a>
    
      <a class="iOS pl__all" href="/2016/03/10/iOS-unit-test.html"><span class="pl__circle"></span><span class="pl__title">iOS单元测试</span><span class="pl__date">16/03/10</span></a>
    
      <a class="iOS pl__all" href="/2016/02/29/iOS-objc-styleguide.html"><span class="pl__circle"></span><span class="pl__title">iOS objc编程规范</span><span class="pl__date">16/02/29</span></a>
    
      <a class="iOS pl__all" href="/2016/02/13/ios-networking-5.html"><span class="pl__circle"></span><span class="pl__title">iOS networking（五）网络请求中的cookie</span><span class="pl__date">16/02/13</span></a>
    
      <a class="iOS pl__all" href="/2016/02/09/ios-networking-4.html"><span class="pl__circle"></span><span class="pl__title">iOS networking（四） http异步文件上传和下载以及进度指示</span><span class="pl__date">16/02/09</span></a>
    
      <a class="iOS pl__all" href="/2016/02/04/ios-networking-3.html"><span class="pl__circle"></span><span class="pl__title">iOS networking（三） http异步请求和https认证</span><span class="pl__date">16/02/04</span></a>
    
      <a class="iOS pl__all" href="/2016/02/03/ios-networking-2.html"><span class="pl__circle"></span><span class="pl__title">iOS networking（二） http异步队列请求</span><span class="pl__date">16/02/03</span></a>
    
      <a class="iOS pl__all" href="/2016/02/03/ios-networking-1.html"><span class="pl__circle"></span><span class="pl__title">iOS networking（一） http同步请求</span><span class="pl__date">16/02/03</span></a>
    
      <a class="react-native pl__all" href="/2016/02/02/react-native-demo.html"><span class="pl__circle"></span><span class="pl__title">react-native（二） 自己写的react-native学习demo和整理的tips</span><span class="pl__date">16/02/02</span></a>
    
      <a class="react-native pl__all" href="/2016/01/11/react-native-helloworld.html"><span class="pl__circle"></span><span class="pl__title">react-native（一） hello world</span><span class="pl__date">16/01/11</span></a>
    
      <a class="iOS pl__all" href="/2016/01/06/iOS-app-versions.html"><span class="pl__circle"></span><span class="pl__title">api如何设计才能支撑多个不同版本的app共存</span><span class="pl__date">16/01/06</span></a>
    
      <a class="web前端 pl__all" href="/2015/12/31/playwith-imageToAscii.html"><span class="pl__circle"></span><span class="pl__title">那些好玩的nodejs插件 - 把图片转为ascii</span><span class="pl__date">15/12/31</span></a>
    
      <a class="web前端 pl__all" href="/2015/12/10/fe-componentization.html"><span class="pl__circle"></span><span class="pl__title">前端开发框架 - seajs+handlebars模块化开发</span><span class="pl__date">15/12/10</span></a>
    
      <a class="web前端 pl__all" href="/2015/12/06/fe-nginx-usage.html"><span class="pl__circle"></span><span class="pl__title">mac环境nginx的安装和使用</span><span class="pl__date">15/12/06</span></a>
    
      <a class="web前端 pl__all" href="/2015/12/03/fe-js-handlebars.html"><span class="pl__circle"></span><span class="pl__title">handlerbars的使用及模板预编译</span><span class="pl__date">15/12/03</span></a>
    
      <a class="web前端 pl__all" href="/2015/12/01/fe-engineering-gulp.html"><span class="pl__circle"></span><span class="pl__title">gulp自动构建工具教程</span><span class="pl__date">15/12/01</span></a>
    
      <a class="web前端 pl__all" href="/2015/11/27/fe-environment.html"><span class="pl__circle"></span><span class="pl__title">前端开发工具和环境搭建</span><span class="pl__date">15/11/27</span></a>
    
      <a class="web前端 pl__all" href="/2015/11/26/rem-em-px.html"><span class="pl__circle"></span><span class="pl__title">css3属性rem的使用</span><span class="pl__date">15/11/26</span></a>
    
      <a class="生活 pl__all" href="/2015/11/26/mylift-github.html"><span class="pl__circle"></span><span class="pl__title">我每天都在github上做些什么</span><span class="pl__date">15/11/26</span></a>
    
      <a class="iOS pl__all" href="/2015/11/24/iOS-affine-transfermation-animation.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效（七）仿射变换-CGAffineTransform</span><span class="pl__date">15/11/24</span></a>
    
      <a class="iOS pl__all" href="/2015/11/22/iOS-library-spring.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效（六）swift动画库spring使用和代码拆解</span><span class="pl__date">15/11/22</span></a>
    
      <a class="iOS pl__all" href="/2015/11/16/iOS-Implicit-Animation.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效（五）layer隐式动画</span><span class="pl__date">15/11/16</span></a>
    
      <a class="iOS pl__all" href="/2015/11/06/iOS-controller-transitioning.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效（四）controller间的自定义过渡效果</span><span class="pl__date">15/11/06</span></a>
    
      <a class="iOS pl__all" href="/2015/11/01/iOS-MotionEffects.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效（三）MotionEffects</span><span class="pl__date">15/11/01</span></a>
    
      <a class="iOS pl__all" href="/2015/10/30/iOS-UIKit-Dynamics.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效（二）UIKit力学行为</span><span class="pl__date">15/10/30</span></a>
    
      <a class="iOS pl__all" href="/2015/10/30/iOS-Animation-UIViewAndCoreAnimation.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效（一）UIView动画和CoreAnimation</span><span class="pl__date">15/10/30</span></a>
    
      <a class="专题 pl__all" href="/2015/10/29/iOS-animation-0.html"><span class="pl__circle"></span><span class="pl__title">iOS动画和特效专题（零）- 大纲和计划</span><span class="pl__date">15/10/29</span></a>
    
      <a class="iOS pl__all" href="/2015/10/17/ios-webView.html"><span class="pl__circle"></span><span class="pl__title">UIWebView和WKWebView的使用及js交互</span><span class="pl__date">15/10/17</span></a>
    
      <a class="iOS pl__all" href="/2015/10/06/ios-swift-quick.html"><span class="pl__circle"></span><span class="pl__title">swift5分钟语法速记</span><span class="pl__date">15/10/06</span></a>
    
      <a class="iOS pl__all" href="/2015/09/20/ios-macro.html"><span class="pl__circle"></span><span class="pl__title">ios宏的使用和技巧</span><span class="pl__date">15/09/20</span></a>
    
      <a class="iOS pl__all" href="/2015/09/11/ios-BLE-4.html"><span class="pl__circle"></span><span class="pl__title">ios蓝牙开发（四）BabyBluetooth蓝牙库介绍</span><span class="pl__date">15/09/11</span></a>
    
      <a class="iOS pl__all" href="/2015/09/07/ios-BLE-3.html"><span class="pl__circle"></span><span class="pl__title">ios蓝牙开发（三）app作为外设被连接的实现</span><span class="pl__date">15/09/07</span></a>
    
      <a class="iOS pl__all" href="/2015/09/02/ios-draw-Graffiti-2.html"><span class="pl__circle"></span><span class="pl__title">ios绘图demo,做一个涂鸦板(下)</span><span class="pl__date">15/09/02</span></a>
    
      <a class="web前端 pl__all" href="/2015/08/29/go-deep-into-unsilder.js.html"><span class="pl__circle"></span><span class="pl__title">深入理解unslider.js源码</span><span class="pl__date">15/08/29</span></a>
    
      <a class="生活 pl__all" href="/2015/08/23/life-keyboardAndHHKB.html"><span class="pl__circle"></span><span class="pl__title">键盘那些事，hhkb开箱</span><span class="pl__date">15/08/23</span></a>
    
      <a class="技术 pl__all" href="/2015/08/22/github-ImagesUploadWebSite.html"><span class="pl__circle"></span><span class="pl__title">自己markdown博客的图床程序</span><span class="pl__date">15/08/22</span></a>
    
      <a class="iOS pl__all" href="/2015/08/19/ios-ThreadAndAsynchronization.html"><span class="pl__circle"></span><span class="pl__title">ios的线程和同步异步操作</span><span class="pl__date">15/08/19</span></a>
    
      <a class="iOS pl__all" href="/2015/08/14/ios-BLE-2.html"><span class="pl__circle"></span><span class="pl__title">ios蓝牙开发（二）ios连接外设的代码实现</span><span class="pl__date">15/08/14</span></a>
    
      <a class="iOS pl__all" href="/2015/07/26/ios-draw-Graffiti.html"><span class="pl__circle"></span><span class="pl__title">ios绘图demo,做一个涂鸦板(上)</span><span class="pl__date">15/07/26</span></a>
    
      <a class="iOS pl__all" href="/2015/07/25/ios-draw-base.html"><span class="pl__circle"></span><span class="pl__title">ios绘图基础</span><span class="pl__date">15/07/25</span></a>
    
      <a class="iOS pl__all" href="/2015/07/17/ios-BLE-1.html"><span class="pl__circle"></span><span class="pl__title">iOS蓝牙开发（一）蓝牙相关基础知识</span><span class="pl__date">15/07/17</span></a>
    
      <a class="专题 pl__all" href="/2015/07/17/ios-BLE-0.html"><span class="pl__circle"></span><span class="pl__title">iOS蓝牙的开发专题</span><span class="pl__date">15/07/17</span></a>
    
      <a class="技术 pl__all" href="/2015/07/07/mybatis.html"><span class="pl__circle"></span><span class="pl__title">MyBatis简单使用的demo</span><span class="pl__date">15/07/07</span></a>
    
      <a class="技术 pl__all" href="/2015/07/06/rabbitmq.html"><span class="pl__circle"></span><span class="pl__title">RabbitMQ使用</span><span class="pl__date">15/07/06</span></a>
    
      <a class="iOS pl__all" href="/2015/06/14/ios-library-masonry.html"><span class="pl__circle"></span><span class="pl__title">Masonry的使用</span><span class="pl__date">15/06/14</span></a>
    
      <a class="专题 pl__all" href="/2015/06/14/ios-library-0.html"><span class="pl__circle"></span><span class="pl__title">iOS中那些好用的第三方库</span><span class="pl__date">15/06/14</span></a>
    
      <a class="iOS pl__all" href="/2015/05/29/ios-develop-tool.html"><span class="pl__circle"></span><span class="pl__title">提高iOS开发效率的工具</span><span class="pl__date">15/05/29</span></a>
    
      <a class="技术 pl__all" href="/2015/05/28/spring-4.html"><span class="pl__circle"></span><span class="pl__title">Spring 文件上传</span><span class="pl__date">15/05/28</span></a>
    
      <a class="技术 pl__all" href="/2015/05/28/spring-3.html"><span class="pl__circle"></span><span class="pl__title">Spring- Hibernate数据基本操作</span><span class="pl__date">15/05/28</span></a>
    
      <a class="技术 pl__all" href="/2015/05/28/spring-2.html"><span class="pl__circle"></span><span class="pl__title">Spring RestController 请求参数详解</span><span class="pl__date">15/05/28</span></a>
    
      <a class="技术 pl__all" href="/2015/05/28/spring-1.html"><span class="pl__circle"></span><span class="pl__title">Spring和hibernate的maven配置</span><span class="pl__date">15/05/28</span></a>
    
      <a class="技术 pl__all" href="/2015/05/28/tomcat-domain-name.html"><span class="pl__circle"></span><span class="pl__title">tomcat部署绑定多个域名</span><span class="pl__date">15/05/28</span></a>
    
      <a class="专题 pl__all" href="/2015/05/28/spring-0.html"><span class="pl__circle"></span><span class="pl__title">Spring4+hibernate专题</span><span class="pl__date">15/05/28</span></a>
    
      <a class="web前端 pl__all" href="/2015/04/29/css-selector.html"><span class="pl__circle"></span><span class="pl__title">css选择器的用法</span><span class="pl__date">15/04/29</span></a>
    
      <a class="技术 pl__all" href="/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html"><span class="pl__circle"></span><span class="pl__title">在Github上搭建Jekyll博客和创建主题</span><span class="pl__date">14/02/12</span></a>
    
      <a class="技术 pl__all" href="/2013/04/23/opensource-licenses.html"><span class="pl__circle"></span><span class="pl__title">五中常见的开源协议整理(BSD,Apache,GPL,LGPL,MIT)</span><span class="pl__date">13/04/23</span></a>
    
    </nav>
  </div> <!-- end #posts-list -->
</aside> <!-- end #sidebar -->
    <div id="post">
      <div id="pjax">
        <article id="post__content">
    <h1 id="post__title" data-identifier="20150819">ios的线程和同步异步操作</h1>
    <h2 id="ios的线程和同步异步操作">ios的线程和同步异步操作</h2>
<blockquote>
  <h2 id="ios的多线程同步异步操作都是我们日常的开发中经常会遇到的问题本文把常见的ios线程同步异步的操作进行了整理">ios的多线程，同步异步操作，都是我们日常的开发中经常会遇到的问题，本文把常见的ios线程，同步异步的操作进行了整理。</h2>
</blockquote>

<p>##代码下载:</p>

<p>我博客中大部分示例代码都上传到了github，地址是：https://github.com/coolnameismy/demo，<a href="https://github.com/coolnameismy/demo">点击跳转代码下载地址</a></p>

<p>本文代码存放目录是 <strong>ThreadAndAsynchronization</strong></p>

<p>如果大家支持，请follow我的github账号，并fork我的项目，有其他问题可以在github上给我留言或者给我发邮件，coolnameismy@hotmail.com，blog的RSS订阅地址：https://zsmsimon.github.io/pages/rss.xml</p>

<h2 id="基础知识">基础知识</h2>
<hr />

<h3 id="1线程和进程-多线程">1.线程和进程 ,多线程</h3>

<p><strong>线程和进程</strong>：网上有一大堆很专业的说法，大多数说的都比较复杂，越复杂的解释其实说的越准确和严谨，但是常常会把人弄糊涂。这里我也不去解释了，大多数场景你可以理解为，一个应用程序就是一个进程，而一个进程可以分为多个线程</p>

<p><strong>多线程</strong>：大多数框架都支持一个进程启多个线程，比如 c#、java、obejctive-c，但是并不是所有的框架都支持，比如flex的框架就不支持多线程。
多线程必须要有多核的cpu支持才行，对应单核cpu，无论你起多少个线程，都是在同一个cpu上跑程序，速度并不会有任何变化。对于多核cpu，多个线程会在多个cpu中同时运行，从而加快程序的执行速度。</p>

<p><strong>多线程适用场景</strong>
最常见的是网络下载，在网络下载的适合，你总不能让程序一直无响应吧，所以你启动另一个线程去下载，留着主线程去相应用户的ui事件。多线程适合一些高io，低cpu的操作。</p>

<h3 id="2同步和异步并行和串行">2.同步和异步，并行和串行</h3>

<p><strong>同步</strong>就是顺序往下执行。举例：烧完水后泡茶</p>

<p><strong>异步</strong>就是几件事情同时在执行。烧水的时候拿出茶具，洗茶具，然后泡茶。其中烧水和拿茶具，洗茶具是同时进行的。</p>

<p><strong>并行和串行</strong> 并行就是几个人同时做一件事，串行就是一个人同时做几件事。</p>

<h3 id="3同步异步操作和多线程的联系和区别">3.同步异步操作和多线程的联系和区别</h3>

<p>同步是我们一般程序顺序执行，异步是大多数时候是多线程，但是却不一定。比如方法回叫和定时执行的方法也是异步操作，单不一定全是多线程。</p>

<h3 id="4ios中的同步异步方法和多线程技术">4.ios中的同步异步方法和多线程技术</h3>

<p>1 performSelector</p>

<p>支持多线程和异步操作，使用简单，但是没有没有线程的一些控制和调度的操作</p>

<p>2 NSThread</p>

<p>支持多线程和异步操作，使用简单，比performSelector稍微复杂一些，performSelector背后使用的就是NSThread，但是没有没有线程的一些控制和调度的操作</p>

<p>3 NSTimer</p>

<p>不支持多线程操作，但是可以执行异步操作，异步操作很方便，最常用的就是定时执行和延迟执行某一方法</p>

<p>4 GCD</p>

<p>支持多线程，同步异步操作，线程控制，线程队列，线程信号等等，IOS和OS中最强大的线程管理都是是它了。
要说缺点的话，就是代码比较复杂，前面能实现的就用前面的把，如果实现不了，那找它准没错。</p>

<p>5  NSOperation</p>

<p>很容易实现异步队列操作，相比GCD比较简单，但功能任然没有GCD强大</p>

<h2 id="代码例子">代码例子</h2>
<hr />

<p>代码注释写的很全，大家直接看注释都能懂，可以在github上把代码下载下来跑跑看。</p>

<pre><code class="language-objective-c">

//ios多线程，同步异步的使用，大家可以切换类，去掉注释跑跑看
- (void)viewDidLoad {
    [super viewDidLoad];


    //使用performSelector的多线程和异步
    //[self performSelectorFunction];

    //使用NSThread的多线程
    //[self NSThreadFunction];

    //使用NSTimer的反面教材
    //[self NSTimerFunction];

    //使用GCD的多线程
    //[self GCDFunction];

}


//耗时2秒的方法
-(void)function1{
    [NSThread sleepForTimeInterval:2];
    NSLog(@"function1 done");
}

</code></pre>

<h2 id="1-performselector的使用">1. performSelector的使用</h2>

<pre><code class="language-objective-c">

/*
 *使用performSelector 的多线程
 *优点：简单
 *缺点：没有串行并线队列，不能实现高级线程调度
 */

-(void)performSelectorFunction{

    NSLog(@"performSelectorFunction start");

    //同步
    //方式执行，直接执行function1
    //[self performSelector:@selector(function1)];

    //异步，线程阻塞
    //延迟两秒执行function1,在function1执行期间，主线程是阻塞的，表现就是界面无响应。
    //[self performSelector:@selector(function1) withObject:nil afterDelay:2];

    //线程阻塞 最后一个参决定是同步还是异步
    // 主线程上执行，主线程阻塞，waitUntilDone:YES：等待执行完成顺序执行，waitUntilDone:NO 先执行后面语句
    //[self performSelectorOnMainThread:@selector(function1) withObject:nil waitUntilDone:NO];

    //异步，非阻塞
    //子线程上执行
    [self performSelectorInBackground:@selector(function1) withObject:nil];

    NSLog(@"performSelectorFunction end");

}

</code></pre>

<h2 id="2-nsthread的使用">2. NSThread的使用</h2>

<pre><code class="language-objective-c">
/*
 *使用NSThread 的多线程
 *优点：简单
 *缺点：没有串行并线队列，不能实现高级线程调度,和performSelector是一样的。
 */

-(void)NSThreadFunction{

    NSLog(@"NSThreadFunction start");

    //同步 阻塞
    //线程暂停 2秒
    //[NSThread sleepForTimeInterval:2];

    //异步 非阻塞
    //显示创建的方式执行
    //NSThread *myThread = [[NSThread alloc]initWithTarget:self selector:@selector(function1) object:nil];
    //[myThread start];

    //异步 非阻塞
    //静态方法执行线程
    //[NSThread detachNewThreadSelector:@selector(function1) toTarget:self withObject:nil];

    NSLog(@"NSThreadFunction end");

}

</code></pre>

<h3 id="创建nsthread主要有两种方式">创建NSThread主要有两种方式：</h3>

<ul>
  <li>1.使用类方法创建</li>
</ul>

<p><code class="highlighter-rouge">[NSThread detachNewThreadSelector:@selector(doInBackgroud) toTarget:self withObject:nil];</code></p>

<ul>
  <li>2.使用传统方式创建</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> NSThread *thread = [[NSThreadalloc] initWithTarget:self selector:@selector(doInBackgroud) object:nil];
[thread start];
</code></pre></div></div>

<h2 id="3-nstimer的使用">3. NSTimer的使用</h2>

<pre><code class="language-objective-c">
/*
 *使反面教材，他不是多线程，但可以执行异步操作。最常用的就是定时执行一个任务，重复或非重复。
 */

-(void)NSTimerFunction{

    NSLog(@"NSTimerFunction start");

    //定时执行任务，可以重复和不重复
    //NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(function1) userInfo:nil repeats:NO];

    //暂时停止定时器
    //[timer setFireDate:[NSDate distantFuture]];
    //重新开启定时器
    //[timer setFireDate:[NSDate distantPast]];
    //永久通知定时器
    //[timer invalidate];
    //timer = nil;

    NSLog(@"NSTimerFunction end");

}


</code></pre>

<h2 id="4-gcd的使用">4. GCD的使用</h2>

<p>GCD的方法很多，用法也很多，这里只列举一些常用的方法。常用的方法包括：</p>

<ul>
  <li>同步、非阻塞执行</li>
  <li>异步非阻塞执行</li>
  <li>一次性执行</li>
  <li>延迟执行</li>
  <li>线程队列串行执行</li>
  <li>线程队列控制（屏障，同步等待，线程暂停和恢复，线程信号量控制等）</li>
</ul>

<pre><code class="language-objective-c">
/*
 *使用GCD 的多线程
 *优点：有很多串行并线队列多线程，block实现线程方法，高级，好用，方法多。
 *缺点：在很多不需要高级控制线程的场景可以不用使用GCD
 */
-(void)GCDFunction{

    NSLog(@"GCDFunction start");

    //获取一个队列
    dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    //dispatch_async：异步方式执行方法（最常用）
    //    dispatch_async(defaultQueue, ^{
    //        [self function1];
    //    });

    //dispatch_sync：同步方式使用场景，比较少用，一般与异步方式进行调用
    //    dispatch_async(defaultQueue, ^{
    //       NSMutableArray *array = [self GCD_sync_Function];
    //       dispatch_async(dispatch_get_main_queue(), ^{
    //           //利用获取的arry在主线程中更新UI
    //
    //       });
    //    });

    //dispatch_once：一次性执行，常常用户单例模式.这种单例模式更安全
    //    static dispatch_once_t onceToken;
    //    dispatch_once(&amp;onceToken, ^{
    //        // code to be executed once
    //        NSLog(@"dispatch_once");
    //    });

    //dispatch_after 延迟异步执行
    //    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC);
    //    dispatch_after(popTime, defaultQueue, ^{
    //        NSLog(@"dispatch_after");
    //    });


    //dispatch_group_async 组线程可以实现线程之间的串联和并联操作
    //    dispatch_group_t group = dispatch_group_create();
    //    NSDate *now = [NSDate date];
    //    //做第一件事 2秒
    //    dispatch_group_async(group, defaultQueue, ^{
    //        [NSThread sleepForTimeInterval:2];
    //         NSLog(@"work 1 done");
    //    });
    //    //做第二件事 5秒
    //    dispatch_group_async(group, defaultQueue, ^{
    //        [NSThread sleepForTimeInterval:5];
    //        NSLog(@"work 2 done");
    //    });
    //
    //    //两件事都完成后会进入方法进行通知
    //    dispatch_group_notify(group, defaultQueue, ^{
    //        NSLog(@"dispatch_group_notify");
    //        NSLog(@"%f",[[NSDate date]timeIntervalSinceDate:now]);//总共用时5秒，因为2个线程同时进行
    //    });


    //dispatch_barrier_async :作用是在并行队列中，等待前面的队列执行完成后在继续往下执行
    //    dispatch_queue_t concurrentQueue = dispatch_queue_create("my.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);
    //    dispatch_async(concurrentQueue, ^{
    //        [NSThread sleepForTimeInterval:2];
    //        NSLog(@"work 1 done");
    //    });
    //    dispatch_async(concurrentQueue, ^{
    //        [NSThread sleepForTimeInterval:2];
    //        NSLog(@"work 2 done");
    //    });
    //    //等待前面的线程完成后执行
    //    dispatch_barrier_async(concurrentQueue, ^{
    //         NSLog(@"dispatch_barrier_async");
    //    });
    //
    //    dispatch_async(concurrentQueue, ^{
    //        [NSThread sleepForTimeInterval:3];
    //        NSLog(@"work 3 done");
    //    });



    //dispatch_semaphore 信号量的使用，串行异步操作
    //    dispatch_semaphore_create　　　创建一个semaphore
    //　　 dispatch_semaphore_signal　　　发送一个信号
    //　　 dispatch_semaphore_wait　　　　等待信号


    /*应用场景1：马路有2股道，3辆车通过 ，每辆车通过需要2秒
     *条件分解:
        马路有2股道 &lt;=&gt;  dispatch_semaphore_create(2) //创建两个信号
        三楼车通过 &lt;=&gt; dispatch_async(defaultQueue, ^{ } 执行三次
        车通过需要2秒 &lt;=&gt;  [NSThread sleepForTimeInterval:2];//线程暂停两秒
     */

    dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);

        dispatch_async(defaultQueue, ^{
            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
            [NSThread sleepForTimeInterval:2];
            NSLog(@"carA pass the road");
            dispatch_semaphore_signal(semaphore);
        });
        dispatch_async(defaultQueue, ^{
            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
            [NSThread sleepForTimeInterval:2];
            NSLog(@"carB pass the road");
            dispatch_semaphore_signal(semaphore);
        });
        dispatch_async(defaultQueue, ^{
            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
            [NSThread sleepForTimeInterval:2];
            NSLog(@"carC pass the road");
            dispatch_semaphore_signal(semaphore);
        });



    //应用场景2 ：原子性保护，保证同时只有一个线程进入操作
    //    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
    //    for(int i=0 ;i&lt; 10000 ;i++){
    //        dispatch_async(defaultQueue, ^{
    //            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    //            NSLog(@"i:%d",i);
    //            dispatch_semaphore_signal(semaphore);
    //        });
    //    }


    NSLog(@"GCDFunction end");
}



</code></pre>

<h2 id="5nsoperation的用法">5.NSOperation的用法</h2>

<h3 id="基本用法">基本用法</h3>

<p>NSOperation需要在NSOperationQueue中使用，通过queue可以实现先进先出的队列任务，可以添加或取消任务，NSOperation有2个重要的子类，分别是：NSInvocationOperation，NSBlockOperation，分别表示调用一个方法或调用一个block的任务。
NSOperation是比GCD更高层次的api，相同的线程操作如果能用NSOperation操作就尽量用，不能实现的线程操作才使用GCD.相比GCD，NSOperation还有个好处，就是任务可以被取消，而GCD不可以。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">NSOperationFunction</span><span class="p">{</span>
    <span class="n">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="nf">alloc</span><span class="p">]</span><span class="nf">init</span><span class="p">];</span>
    <span class="c1">//设置队列最大同时进行的任务数量，1为串行队列</span>
    <span class="p">[</span><span class="n">queue</span> <span class="nf">setMaxConcurrentOperationCount</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
    <span class="c1">//添加一个block任务</span>
    <span class="p">[</span><span class="n">queue</span> <span class="nf">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
       <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"block task 1"</span><span class="p">);</span>
    <span class="p">}];</span>
    <span class="p">[</span><span class="n">queue</span> <span class="nf">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"block task 2"</span><span class="p">);</span>
    <span class="p">}];</span>
    <span class="c1">//显示添加一个block任务</span>
    <span class="n">NSBlockOperation</span> <span class="o">*</span><span class="n">block1</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBlockOperation</span> <span class="nf">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"block task 3"</span><span class="p">);</span>
    <span class="p">}];</span>
    <span class="c1">//设置任务优先级</span>
    <span class="c1">//说明：优先级高的任务，调用的几率会更大,但不表示一定先调用</span>
    <span class="p">[</span><span class="n">block1</span> <span class="nf">setQueuePriority</span><span class="p">:</span><span class="n">NSOperationQueuePriorityHigh</span><span class="p">];</span>
    <span class="p">[</span><span class="n">queue</span> <span class="nf">addOperation</span><span class="p">:</span><span class="n">block1</span><span class="p">];</span>

    <span class="n">NSBlockOperation</span> <span class="o">*</span><span class="n">block2</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBlockOperation</span> <span class="nf">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"block task 4，任务3依赖4"</span><span class="p">);</span>
    <span class="p">}];</span>
    <span class="p">[</span><span class="n">queue</span> <span class="nf">addOperation</span><span class="p">:</span><span class="n">block2</span><span class="p">];</span>
    <span class="c1">//任务3依赖4</span>
    <span class="p">[</span><span class="n">block1</span> <span class="nf">addDependency</span><span class="p">:</span><span class="n">block2</span><span class="p">];</span>
    <span class="c1">//设置任务完成的回调</span>
    <span class="p">[</span><span class="n">block2</span> <span class="nf">setCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
         <span class="n">NSLog</span><span class="p">(</span><span class="s">@"block task 4 comlpete"</span><span class="p">);</span>
    <span class="p">}];</span>

    <span class="c1">//设置block1完成后才会继续往下走</span>
    <span class="p">[</span><span class="n">block1</span> <span class="nf">waitUntilFinished</span><span class="p">];</span>
     <span class="n">NSLog</span><span class="p">(</span><span class="s">@"block task 3 is waitUntilFinished!"</span><span class="p">);</span>

    <span class="c1">//初始化一个子任务</span>
    <span class="n">NSInvocationOperation</span> <span class="o">*</span><span class="n">oper1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSInvocationOperation</span> <span class="nf">alloc</span><span class="p">]</span><span class="nf">initWithTarget</span><span class="p">:</span><span class="n">self</span> <span class="nf">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">function1</span><span class="p">)</span> <span class="n">object</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">[</span><span class="n">queue</span> <span class="nf">addOperation</span><span class="p">:</span><span class="n">oper1</span><span class="p">];</span>

    <span class="p">[</span><span class="n">queue</span> <span class="nf">waitUntilAllOperationsAreFinished</span><span class="p">];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"queue comlpeted"</span><span class="p">);</span>

    <span class="c1">//    取消全部操作</span>
    <span class="c1">//    [queue cancelAllOperations];</span>
    <span class="c1">//    暂停操作/恢复操作/是否暂定状态</span>
    <span class="c1">//    [queue setSuspended:YES];[queue setSuspended:NO];[queue isSuspended];</span>


    <span class="c1">//操作优先级</span>



    <span class="c1">//      [queue waitUntilAllOperationsAreFinished];</span>

</code></pre></div></div>

<p>执行结果</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2016-02-04 15:11:54.283 ThreadAndAsynchronization[28948:3783683] block task 1
2016-02-04 15:11:56.358 ThreadAndAsynchronization[28948:3783684] block task 2
2016-02-04 15:11:58.430 ThreadAndAsynchronization[28948:3783683] block task 4，任务3依赖4
2016-02-04 15:11:58.430 ThreadAndAsynchronization[28948:3783694] block task 4 comlpete
2016-02-04 15:12:00.504 ThreadAndAsynchronization[28948:3783683] block task 3
2016-02-04 15:12:00.504 ThreadAndAsynchronization[28948:3783527] block task 4 is waitUntilFinished!
2016-02-04 15:12:02.573 ThreadAndAsynchronization[28948:3783694] function1 done
2016-02-04 15:12:02.573 ThreadAndAsynchronization[28948:3783527] queue comlpeted
</code></pre></div></div>

<p>有2个值得注意的地方，第一个是mainQueue，第二个是maxConcurrentOperationCount。</p>

<p>mainQueue是通过 <code class="highlighter-rouge">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</code> 获取到，它代表主队列，也就是UI队列，所以用到mainQueue队列的时候一般用于更新ui界面，且特别注意在这个队列中执行的方法，要考虑到会不会阻塞进程。</p>

<p>maxConcurrentOperationCount：最多有多少个队列可以同时执行，默认是5，当设置为1是，队列是一个串行队列，设置&gt;1时，队列是一个并行队列。但是在主队列上设置同时执行的任务是没有效果的！如果没有设置最大并发数，那么并发的个数是由<strong>系统内存和CPU决定的</strong>，可能内存多久开多一点，内存少就开少一点。</p>

<h3 id="队列的取消暂停和恢复">队列的取消，暂停和恢复</h3>

<ul>
  <li>取消队列的所有操作 <code class="highlighter-rouge">[queue cancelAllOperations];</code></li>
  <li>暂停队列恢复</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//    [queue setSuspended:YES];
//    [queue setSuspended:NO];
//    [queue isSuspended];
</code></pre></div></div>

<h3 id="优先级">优先级</h3>
<p>、、、、objc
     //显示添加一个block任务
      NSBlockOperation *block1 = [NSBlockOperation blockOperationWithBlock:^{
          sleep(2);
          NSLog(@”block task 3”);
      }];
      //设置任务优先级
      //说明：优先级高的任务，调用的几率会更大,但不表示一定先调用
      [block1 setQueuePriority:NSOperationQueuePriorityHigh];</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [queue addOperation:block1]; 、、、、
</code></pre></div></div>

<p>优先级高的任务，调用的几率会更大,但不表示一定先调用</p>

<h3 id="操作依赖">操作依赖</h3>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//block1依赖block2</span>
    <span class="p">[</span><span class="n">block1</span> <span class="nf">addDependency</span><span class="p">:</span><span class="n">block2</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="操作完成的监听">操作完成的监听</h3>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//设置任务完成的回调</span>
    <span class="p">[</span><span class="n">block2</span> <span class="nf">setCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
         <span class="n">NSLog</span><span class="p">(</span><span class="s">@"block task 4 comlpete"</span><span class="p">);</span>
    <span class="p">}];</span>
</code></pre></div></div>

<p>除了这个方法以外，还可以调用 <code class="highlighter-rouge">waitUntilFinished</code>方法，等待完成操作或队列全部完成后继续执行代码。这是一个很好的顺序执行代码的异步编程最佳实践！</p>

<p>queue也有对应的方法，叫做<code class="highlighter-rouge">waitUntilAllOperationsAreFinished</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [queue waitUntilAllOperationsAreFinished];
   NSLog(@"queue comlpeted");
</code></pre></div></div>

<h3 id="更好的控制nsoperation">更好的控制NSOperation</h3>

<p>如果这些自带的api还不能满足你对线程和队列任务的控制，你可以尝试继承NSOperation，重写一些关键方法。</p>

<h2 id="代码下载">代码下载:</h2>

<h4 id="我博客中大部分示例代码都上传到了github地址是httpsgithubcomcoolnameismydemo点击跳转代码下载地址">我博客中大部分示例代码都上传到了github，地址是：https://github.com/coolnameismy/demo，<a href="https://github.com/coolnameismy/demo">点击跳转代码下载地址</a></h4>
<h4 id="本文代码存放目录是threadandasynchronization">本文代码存放目录是ThreadAndAsynchronization</h4>

<h2 id="最后">最后</h2>

<p>感谢收看，如果对大家有帮助，请<a href="https://github.com/coolnameismy">github上follow和star</a>，本文发布在<a href="https://zsmsimon.github.io/">刘彦玮的技术博客</a>，转载请注明出处</p>

    <div class="declare">
        <div>

        </div>
    </div>
</article>
<!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://localhost:4000/2015/08/19/ios-ThreadAndAsynchronization.html&text=ios的线程和同步异步操作" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://github.com/ZSMSimon" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://localhost:4000/2015/08/19/ios-ThreadAndAsynchronization.html&title=ios的线程和同步异步操作" target="_blank"></a>
    <!-- <div class="share-info">分享一下~</div> -->
</div>
<div id="qrcode" >
	<img src="http://localhost:4000/assets/images/qrcode.jpg" style="margin: 0 auto;display: block;" width="200" height="200" alt="">
</div>
<!-- end #post__share -->
<div id="disqus_thread" name="coolnameismy">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div>


            <!---->
    <!--<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>-->
    <!--&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a>-->
    <!--&nbsp;&nbsp;|&nbsp;&nbsp;Hosted on <a href="https://pages.github.com" target="_blank">Github</a></p>-->
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.pjax.js"></script>
<script src="/assets/js/nprogress.js"></script>
<script src="/assets/js/searchbox.js"></script>
<script src="/assets/js/script.js"></script>


    <script>
    //百度站点统计,排除localhost
    if(window.location.host.indexOf("localhost") ==-1 &&  window.location.host.indexOf("127.0.0.1") == -1){

        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?2c1583237ca3f5343d8dab0140019ca7";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }
</script>
   </body>
 </html>